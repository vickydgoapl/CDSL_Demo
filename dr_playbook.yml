# dr_rh_certified.yml
# ────────────────────────────────────────────────────────────────
# Disaster-Recovery workflow that uses ONLY Red Hat-supported content
# ────────────────────────────────────────────────────────────────

###############################################################################
# PLAY 1 – PROTECT  (primary site)  ➜  create database + file backups
###############################################################################
- name: Stage 1 – Protect (Primary site)
  hosts: primary
  become: true # Connects as ansibleuser, then uses sudo for root privileges on primary-server
  vars:
    # Use ansible_date_time for a more robust timestamp, available on all hosts
    # and ensures consistency across different Ansible versions/environments.
    current_timestamp: "{{ ansible_date_time.strftime('%Y%m%d%H%M%S') }}"
    db_name: myapp
    db_user: postgres
    # -------------------------------------------------------------------------
    # IMPORTANT: Define 'db_password' securely.
    # Recommended ways:
    # 1. Ansible Vault: Encrypt a file (e.g., group_vars/all/vault.yml)
    #    containing: db_password: "your_actual_db_password"
    #    Then run playbook with 'ansible-playbook --ask-vault-pass ...'
    # 2. As an --extra-vars command-line argument (LESS SECURE for production):
    #    ansible-playbook ... --extra-vars "db_password=your_actual_db_password"
    # 3. In your inventory.ini under [all:vars] (LESS SECURE for production):
    #    db_password='your_actual_db_password'
    # -------------------------------------------------------------------------
    db_password: "{{ lookup('ansible.builtin.var', 'db_password', default='') }}"

    dump_file: "{{ backup_root }}/{{ db_name }}_{{ current_timestamp }}.sql.gz"
    data_archive: "{{ backup_root }}/data_{{ current_timestamp }}.tgz"
    backup_root: /var/backups/dr
    app_data_path: /var/www/myapp # Centralize common application data path

  tasks:
    - name: Ensure backup directory exists
      ansible.builtin.file:
        path: "{{ backup_root }}"
        state: directory
        mode: "0750"

    - name: Dump and compress PostgreSQL database
      # Using 'command' module for flexibility with piping and compression.
      # Requires pg_dump and gzip to be installed on the primary-server.
      ansible.builtin.command: >
        pg_dump -U {{ db_user }} {{ db_name }} | gzip -9 -c > {{ dump_file }}
      environment:
        # PGPASSWORD is crucial for database authentication.
        PGPASSWORD: "{{ db_password }}"
      changed_when: true # Always report a change for dump operations
      tags: [backup, database]

    - name: Create tarball of application data
      # Using 'command' module with 'tar' for compatibility and direct control.
      # 'creates' argument ensures idempotency: task runs only if file doesn't exist.
      ansible.builtin.command: >
        tar --create --gzip --file {{ data_archive }} -C {{ app_data_path }} .
      args:
        creates: "{{ data_archive }}"
      changed_when: true # Always report a change for archive operations
      tags: [backup, files]

    - name: Verify backup artifacts exist
      # Check if the created backup files actually exist on the primary-server.
      ansible.builtin.stat:
        path: "{{ item }}"
      loop:
        - "{{ dump_file }}"
        - "{{ data_archive }}"
      register: art_stats

    - name: Fail if any artifact is missing
      # Assert that all backup files were successfully created.
      ansible.builtin.assert:
        that: "item.stat.exists"
        fail_msg: "Backup artifact {{ item.stat.path }} is missing!"
      loop: "{{ art_stats.results }}"

    - name: Register artifacts for transfer
      # This registers the list of generated backup files for subsequent plays
      # to ensure the correct paths are used for transfer.
      ansible.builtin.set_fact:
        backup_package: "{{ [dump_file, data_archive] }}"
      tags: always # Always run this task to ensure 'backup_package' is set

###############################################################################
# PLAY 2 – TRANSFER  (primary ➜ DR host)  ➜  copy artifacts off-site
###############################################################################
- name: Stage 2 – Transfer (Primary ➜ DR)
  hosts: primary
  become: true # Connects as ansibleuser, then uses sudo for root privileges on primary-server
  vars:
    # dr_host will be the first host defined in the 'dr' group of your inventory.
    dr_host: "{{ groups['dr'][0] }}"
    dr_incoming: /srv/dr_incoming # Directory on DR host for incoming backups

  tasks:
    - name: Ensure incoming directory exists on DR host
      # This task is delegated to the DR host, ensuring the directory exists there.
      ansible.builtin.file:
        path: "{{ dr_incoming }}"
        state: directory
        mode: "0750"
      delegate_to: "{{ dr_host }}"

    - name: Copy backup artifacts to DR host (scp)
      # This task runs on the primary-server and uses 'scp' to transfer files
      # directly from primary-server to dr-server.
      # Requires passwordless SSH from 'root@primary-server' to 'root@dr-server'.
      # (Set up in the 'setup_primary_server.sh' script and manual steps.)
      ansible.builtin.shell: |
        scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{ item }} {{ dr_host }}:{{ dr_incoming }}/
      loop: "{{ hostvars[inventory_hostname].backup_package }}"
      changed_when: true # Indicate a change as scp doesn't natively report idempotency
      tags: [transfer]

###############################################################################
# PLAY 3 – RECOVER  (DR site)  ➜  restore when dr_action=failover
###############################################################################
- name: Stage 3 – Recover (only when dr_action=failover)
  hosts: dr
  become: true # Connects as ansibleuser, then uses sudo for root privileges on dr-server
  vars:
    # 'dr_action' controls if recovery proceeds. Default to 'standby' (no failover).
    # To run recovery, pass --extra-vars "dr_action=failover" to ansible-playbook.
    dr_action: "{{ dr_action | default('standby') }}"
    incoming_dir: /srv/dr_incoming # Directory on DR host where backups were transferred
    restore_root: /srv/dr_restore # Directory on DR host for restored application data
    db_name: myapp
    db_user: postgres
    # db_password will be retrieved from the same source as in Play 1.

  tasks:
    - name: Skip unless fail-over requested
      # Use meta: end_play to stop further tasks in this play if 'dr_action' is not 'failover'.
      ansible.builtin.meta: end_play
      when: dr_action != 'failover'

    - name: Create restore directory
      ansible.builtin.file:
        path: "{{ restore_root }}"
        state: directory
        mode: "0750"

    - name: Find latest data archive
      # Locates the most recently modified tarball in the incoming directory.
      ansible.builtin.find:
        paths: "{{ incoming_dir }}"
        patterns: "data_*.tgz"
        recurse: no
        age_stamp: mtime # Find the latest based on modification time
      register: data_archives

    - name: Extract latest data archive
      # Extracts the found data archive to the restore directory.
      ansible.builtin.unarchive:
        src: "{{ (data_archives.files | sort(attribute='mtime', reverse=true) | first).path }}"
        dest: "{{ restore_root }}"
        remote_src: true # Source file is on the remote (DR) host
      when: data_archives.matched > 0 # Only attempt extraction if an archive was found
      tags: [restore, files]

    - name: Find latest DB dump
      # Locates the most recently modified database dump in the incoming directory.
      ansible.builtin.find:
        paths: "{{ incoming_dir }}"
        patterns: "{{ db_name }}_*.sql.gz"
        age_stamp: mtime
      register: db_dumps

    - name: Restore PostgreSQL dump
      # Restores the database using gunzip and psql.
      # Requires psql, gunzip to be installed on the dr-server.
      ansible.builtin.command: >
        bash -c 'gunzip -c "{{ (db_dumps.files | sort(attribute="mtime", reverse=true) | first).path }}" |
                  psql -U {{ db_user }} {{ db_name }}'
      environment:
        PGPASSWORD: "{{ db_password }}"
      when: db_dumps.matched > 0 # Only attempt restore if a dump was found
      changed_when: true # Indicate a change as it's a restore operation
      tags: [restore, database]

    - name: Start application service
      # Ensures the 'myapp' systemd service is started and enabled to run on boot.
      ansible.builtin.systemd:
        name: myapp
        state: started
        enabled: true
      tags: [restore, services]

    - name: Check application health endpoint
      # Waits for the application to become healthy by checking its HTTP endpoint.
      ansible.builtin.uri:
        url: http://localhost/health
        status_code: 200
        retries: 5 # Retry 5 times
        delay: 10 # Wait 10 seconds between retries
        register: health_check
        until: health_check.status == 200 # Continue until status code 200 is received
      tags: [validate]
