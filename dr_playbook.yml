# dr_rh_certified.yml
# ...

- name: Stage 1 – Protect (Primary site)
  hosts: primary
  become: true
  vars:
    db_name: myapp
    db_user: postgres
    db_password: "pass@123"
    backup_root: /var/backups/dr
    app_data_path: /var/www/myapp
    control_node_fetch_dir: "/tmp/ansible_dr_fetched_backups"

  tasks:
    - name: Ensure backup directory exists on primary
      ansible.builtin.file:
        path: "{{ backup_root }}"
        state: directory
        mode: "0750"

    - name: Dump and compress PostgreSQL database
      ansible.builtin.shell: >
        pg_dump -U {{ db_user }} {{ db_name }} | gzip -9 -c > {{ backup_root }}/{{ db_name }}_$(date +%Y%m%d%H%M%S).sql.gz
      environment:
        PGPASSWORD: "{{ db_password }}"
      changed_when: true
      tags: [backup, database]

    - name: Create tarball of application data
      ansible.builtin.shell: >
        tar --create --gzip --file {{ backup_root }}/data_$(date +%Y%m%d%H%M%S).tgz -C {{ app_data_path }} .
      changed_when: true
      tags: [backup, files]

    - name: Wait 15 seconds for artifacts to settle on disk
      ansible.builtin.pause:
        seconds: 15

    - name: Find all DB dump files
      ansible.builtin.find:
        paths: "{{ backup_root }}"
        patterns: "{{ db_name }}_*.sql.gz"
        file_type: file
        # Removed 'sortby' parameter
      register: all_db_dumps

    - name: Find all data archive files
      ansible.builtin.find:
        paths: "{{ backup_root }}"
        patterns: "data_*.tgz"
        file_type: file
        # Removed 'sortby' parameter
      register: all_data_archives

    - name: DEBUG - Show discovered artifact paths (unsorted)
      ansible.builtin.debug:
        msg:
          - "Discovered DB Dumps (unsorted): {{ all_db_dumps.files | map(attribute='path') | list }}"
          - "Discovered Data Archives (unsorted): {{ all_data_archives.files | map(attribute='path') | list }}"

    - name: Fail if latest DB dump was not found
      ansible.builtin.assert:
        that:
          # Check if any files were matched
          - all_db_dumps.matched > 0
          # Ensure the latest file is available after sorting.
          # We use '| sort(attribute="mtime", reverse=true) | first' to get the latest.
          - (all_db_dumps.files | sort(attribute="mtime", reverse=true) | first).path is defined
        fail_msg: "No recent DB dump found matching pattern {{ db_name }}_*.sql.gz in {{ backup_root }}"

    - name: Fail if latest data archive was not found
      ansible.builtin.assert:
        that:
          - all_data_archives.matched > 0
          - (all_data_archives.files | sort(attribute="mtime", reverse=true) | first).path is defined
        fail_msg: "No recent data archive found matching pattern data_*.tgz in {{ backup_root }}"

    - name: Register artifacts for fetch (primary paths)
      ansible.builtin.set_fact:
        primary_backup_package:
          # Sort the found files by 'mtime' in reverse (newest first) and pick the first one.
          - "{{ (all_db_dumps.files | sort(attribute='mtime', reverse=true) | first).path }}"
          - "{{ (all_data_archives.files | sort(attribute='mtime', reverse=true) | first).path }}"
      tags: always

    - name: Fetch backup artifacts from primary to control node
      ansible.builtin.fetch:
        src: "{{ item }}"
        dest: "{{ control_node_fetch_dir }}"
        flat: true
      loop: "{{ primary_backup_package }}"
      register: fetched_results

    - name: Register fetched artifact paths on control node
      ansible.builtin.set_fact:
        control_node_backup_package: |
          {% set fetched_paths = [] %}
          {% for result in fetched_results.results %}
            {% if result.dest is defined %}
              {% set _ = fetched_paths.append(result.dest) %}
            {% endif %}
          {% endfor %}
          {{ fetched_paths }}
      tags: always

# ... (rest of Play 2 and Play 3) ...

- name: Stage 3 – Recover (only when dr_action=failover)
  hosts: dr
  become: true
  vars:
    dr_action: "{{ dr_action | default('standby') }}"
    incoming_dir: /srv/dr_incoming
    restore_root: /srv/dr_restore
    db_name: myapp
    db_user: postgres
    db_password: "{{ lookup('ansible.builtin.var', 'db_password', default='') }}"

  tasks:
    - name: Skip unless fail-over requested
      ansible.builtin.meta: end_play
      when: dr_action != 'failover'

    - name: Create restore directory
      ansible.builtin.file:
        path: "{{ restore_root }}"
        state: directory
        mode: "0750"

    - name: Find all data archive files on DR
      ansible.builtin.find:
        paths: "{{ incoming_dir }}"
        patterns: "data_*.tgz"
        file_type: file
        # Removed 'sortby' parameter
      register: all_data_archives_dr # Changed name to avoid conflict with primary's register

    - name: Extract latest data archive
      ansible.builtin.unarchive:
        src: "{{ (all_data_archives_dr.files | sort(attribute='mtime', reverse=true) | first).path }}"
        dest: "{{ restore_root }}"
        remote_src: true
      when: all_data_archives_dr.matched > 0
      tags: [restore, files]

    - name: Find all DB dump files on DR
      ansible.builtin.find:
        paths: "{{ incoming_dir }}"
        patterns: "{{ db_name }}_*.sql.gz"
        file_type: file
        # Removed 'sortby' parameter
      register: all_db_dumps_dr # Changed name to avoid conflict with primary's register

    - name: Restore PostgreSQL dump
      ansible.builtin.shell: >
        bash -c 'gunzip -c "{{ (all_db_dumps_dr.files | sort(attribute="mtime", reverse=true) | first).path }}" |
                  psql -U {{ db_user }} {{ db_name }}'
      environment:
        PGPASSWORD: "{{ db_password }}"
      when: all_db_dumps_dr.matched > 0
      changed_when: true
      tags: [restore, database]

    - name: Start application service
      ansible.builtin.systemd:
        name: myapp
        state: started
        enabled: true
      tags: [restore, services]

    - name: Check application health endpoint
      ansible.builtin.uri:
        url: http://localhost/health
        status_code: 200
        retries: 5
        delay: 10
        register: health_check
        until: health_check.status == 200
      tags: [validate]
