# dr_rh_certified.yml
# ────────────────────────────────────────────────────────────────
# Disaster-Recovery workflow that uses ONLY Red Hat-supported content
# ────────────────────────────────────────────────────────────────

###############################################################################
# PLAY 1 – PROTECT  (primary site)  ➜  create database + file backups
###############################################################################
- name: Stage 1 – Protect (Primary site)
  hosts: primary
  become: true
  vars:
    backup_root: /var/backups/dr
    ts: "{{ '%Y%m%d%H%M%S' | strftime }}"
    db_name: sample_db
    db_user: admin        # adjust as needed
    # Ensure db_password is provided securely, e.g., via Ansible Vault
    # or as an extra var (--extra-vars "db_password=your_secret_password")
    # db_password: "your_secret_password" # This line should be vaulted or passed via extra vars
    dump_file: "{{ backup_root }}/{{ db_name }}_{{ ts }}.sql.gz"
    data_archive: "{{ backup_root }}/data_{{ ts }}.tgz"

  tasks:
    # Ensure backup directory
    - name: Ensure backup directory exists
      ansible.builtin.file:
        path: "{{ backup_root }}"
        state: directory
        mode: "0750"

    # Dump + compress the database
    - name: Dump and compress PostgreSQL database
      ansible.builtin.command: "sudo -u {{ db_user }} pg_dump -Fc -f {{ dump_file }} -U {{ db_user }} {{ db_name }}"
      environment:
        # PGPASSWORD should be provided securely (e.g., via Ansible Vault)
        # Using lookup('ansible.builtin.var', 'db_password') implies db_password
        # is available in vars, inventory, or as an extra var.
        PGPASSWORD: ""
      changed_when: true
      tags: [backup, database]

    # -------------------- UPDATED TASK ---------------------------
    # Replaces the former ansible.builtin.archive (non-certified for this context)
    - name: Create tarball of application data
      ansible.builtin.command: >
        tar --create --gzip --file {{ data_archive }} -C /var/www/sample_db .
      args:
        creates: "{{ data_archive }}"        # makes task idempotent
      changed_when: true
      tags: [backup, files]
    # -------------------------------------------------------------

    # Verify artifacts
    - name: Verify backup artifacts exist
      ansible.builtin.stat:
        path: "{{ item }}"
      loop:
        - "{{ dump_file }}"
        - "{{ data_archive }}"
      register: art_stats

    - name: Fail if any artifact is missing
      ansible.builtin.assert:
        that: "item.stat.exists"
        fail_msg: "Backup artifact {{ item.stat.path }} is missing!"
      loop: "{{ art_stats.results }}"

    # Pass list of artifacts to later plays
    - name: Register artifacts for transfer
      ansible.builtin.set_fact:
        backup_package: "{{ [dump_file, data_archive] }}"
      tags: always

###############################################################################
# PLAY 2 – TRANSFER  (primary ➜ DR host)  ➜  copy artifacts off-site
###############################################################################
- name: Stage 2 – Transfer (Primary ➜ DR)
  hosts: primary
  become: true
  vars:
    # Ensure 'dr' group exists and contains at least one host in your inventory
    dr_host: "{{ groups['dr'][0] }}"
    dr_incoming: /srv/dr_incoming

  tasks:
    - name: Ensure incoming directory exists on DR host
      ansible.builtin.file:
        path: "{{ dr_incoming }}"
        state: directory
        mode: "0750"
      delegate_to: "{{ dr_host }}"

    - name: Copy backup artifacts to DR host (scp)
      # This task assumes passwordless SSH is configured between the primary host
      # and the DR host for the user executing the Ansible playbook.
      # 'scp' is executed on the primary host.
      ansible.builtin.shell: |
        scp -o StrictHostKeyChecking=no {{ item }} {{ dr_host }}:{{ dr_incoming }}/
      loop: "{{ hostvars[inventory_hostname].backup_package }}"
      changed_when: true
      tags: [transfer]

###############################################################################
# PLAY 3 – RECOVER  (DR site)  ➜  restore when dr_action=failover
###############################################################################
- name: Stage 3 – Recover (only when dr_action=failover)
  hosts: dr
  become: true
  vars:
    dr_action: "{{ dr_action | default('standby') }}" # Default to 'standby' mode
    incoming_dir: /srv/dr_incoming
    restore_root: /srv/dr_restore
    db_name: myapp
    db_user: postgres
    # Ensure db_password is provided securely (e.g., via Ansible Vault)
    # db_password: "your_secret_password" # This line should be vaulted or passed via extra vars

  tasks:
    - name: Skip unless fail-over requested
      ansible.builtin.meta: end_play
      when: dr_action != 'failover'

    - name: Create restore directory
      ansible.builtin.file:
        path: "{{ restore_root }}"
        state: directory
        mode: "0750"

    # Find and extract latest data archive
    - name: Find latest data archive
      ansible.builtin.find:
        paths: "{{ incoming_dir }}"
        patterns: "data_*.tgz"
        recurse: no
        age_stamp: mtime # Finds the latest based on modification time
      register: data_archives

    - name: Extract latest data archive
      ansible.builtin.unarchive:
        src: "{{ (data_archives.files | sort(attribute='mtime') | last).path }}" # Correctly select the latest file
        dest: "{{ restore_root }}"
        remote_src: yes # Source file is on the remote (DR) host
      when: data_archives.matched > 0 # Only attempt if archives were found
      tags: [restore, files]

    # Find and restore latest DB dump
    - name: Find latest DB dump
      ansible.builtin.find:
        paths: "{{ incoming_dir }}"
        patterns: "{{ db_name }}_*.sql.gz"
        age_stamp: mtime # Also find latest DB dump by modification time
      register: db_dumps

    - name: Restore PostgreSQL dump
      ansible.builtin.command: >
        bash -c 'gunzip -c "{{ (db_dumps.files | sort(attribute="mtime") | last).path }}" |
                  psql -U {{ db_user }} {{ db_name }}'
      environment:
        # PGPASSWORD should be provided securely (e.g., via Ansible Vault)
        PGPASSWORD: "{{ lookup('ansible.builtin.var', 'db_password', default='') }}"
      when: db_dumps.matched > 0 # Only attempt if dumps were found
      changed_when: true
      tags: [restore, database]

    # Bring application up and confirm health
    - name: Start application service
      ansible.builtin.systemd:
        name: myapp
        state: started
      tags: [restore, services]

    - name: Check application health endpoint
      ansible.builtin.uri:
        url: http://localhost/health
        status_code: 200
        retries: 5
        delay: 10
        register: health
        until: health.status == 200
      tags: [validate]
