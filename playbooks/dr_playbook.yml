---
###############################################################################
# Disaster-Recovery workflow (Red Hat-supported content)
#  • Generates per-tag CSV reports for every stage
###############################################################################

###############################################################################
# PLAY 1 – PROTECT  (primary)  ➜  create DB + file backups
###############################################################################
- name: Stage 1 – Protect (Primary site)
  hosts: primary
  become: true

  vars:
    # ————— user parameters ——————————————————————————
    db_name:  myapp
    db_user:  postgres
    db_password: "pass@123"           # vault / prompt in prod
    backup_root: /var/backups/dr
    app_data_path: /var/www/myapp
    control_node_fetch_dir: "/tmp/ansible_dr_fetched_backups"

    # ————— reporting helpers ————————————————————————
    _dr_report: {}                               # tag → list<rows>
    _csv_time: "{{ ansible_date_time.iso8601_basic }}"

  tasks:
  # -------------------------------------------------------------------------
  # Create backup directory
  # -------------------------------------------------------------------------
  - block:
      - name: Ensure backup directory exists
        ansible.builtin.file:
          path: "{{ backup_root }}"
          state: directory
          mode: "0750"
        register: res_backup_dir
        tags: [backup, files]

      - name: Record result (backup dir)
        ansible.builtin.set_fact:
          _dr_report: "{{ _dr_report | combine({
              item: (_dr_report.get(item, []) + [ {
                task:  'Ensure backup directory exists',
                host:  inventory_hostname,
                rc:    res_backup_dir.rc    | default(0),
                changed: res_backup_dir.changed | default(false),
                failed:  res_backup_dir.failed  | default(false),
                msg:     res_backup_dir.msg     | default('')
              } ]) }, recursive=True) }}"
        loop: ['backup','files']
        loop_control: { label: "{{ item }}" }
        tags: [always]

  # -------------------------------------------------------------------------
  # Dump the PostgreSQL DB
  # -------------------------------------------------------------------------
  - block:
      - name: Dump and compress PostgreSQL database
        ansible.builtin.shell: >
          pg_dump -U {{ db_user }} {{ db_name }} |
          gzip -9 -c > {{ backup_root }}/{{ db_name }}_$(date +%Y%m%d%H%M%S).sql.gz
        environment: { PGPASSWORD: "{{ db_password }}" }
        changed_when: true
        register: res_dump_db
        tags: [backup, database]

      - name: Record result (DB dump)
        ansible.builtin.set_fact:
          _dr_report: "{{ _dr_report | combine({
              item: (_dr_report.get(item, []) + [ {
                task:  'Dump PostgreSQL DB',
                host:  inventory_hostname,
                rc:    res_dump_db.rc       | default(0),
                changed: res_dump_db.changed| default(false),
                failed:  res_dump_db.failed | default(false),
                msg:     res_dump_db.msg    | default('')
              } ]) }, recursive=True) }}"
        loop: ['backup','database']
        loop_control: { label: "{{ item }}" }
        tags: [always]

  # -------------------------------------------------------------------------
  # Tarball application data
  # -------------------------------------------------------------------------
  - block:
      - name: Create tarball of application data
        ansible.builtin.shell: >
          tar -czf {{ backup_root }}/data_$(date +%Y%m%d%H%M%S).tgz -C {{ app_data_path }} .
        changed_when: true
        register: res_tarball
        tags: [backup, files]

      - name: Record result (tarball)
        ansible.builtin.set_fact:
          _dr_report: "{{ _dr_report | combine({
              item: (_dr_report.get(item, []) + [ {
                task:  'Create data tarball',
                host:  inventory_hostname,
                rc:    res_tarball.rc       | default(0),
                changed: res_tarball.changed| default(false),
                failed:  res_tarball.failed | default(false),
                msg:     res_tarball.msg    | default('')
              } ]) }, recursive=True) }}"
        loop: ['backup','files']
        loop_control: { label: "{{ item }}" }
        tags: [always]

  # -------------------------------------------------------------------------
  # Pause for disk flush
  # -------------------------------------------------------------------------
  - pause:
      seconds: 15
    register: res_pause
    tags: [misc]

  - ansible.builtin.set_fact:
      _dr_report: "{{ _dr_report | combine({
          'misc': (_dr_report.get('misc', []) + [ {
            task: 'Pause 15 s',
            host: inventory_hostname,
            rc:   0,
            changed: false,
            failed: false,
            msg:  ''
          } ]) }, recursive=True) }}"
    tags: [always]

  # -------------------------------------------------------------------------
  # Locate newest DB dump & data tar
  # -------------------------------------------------------------------------
  - name: Find DB dump files
    ansible.builtin.find:
      paths: "{{ backup_root }}"
      patterns: "{{ db_name }}_*.sql.gz"
      file_type: file
    register: find_db_dumps
    tags: [backup, database]

  - name: Find data archive files
    ansible.builtin.find:
      paths: "{{ backup_root }}"
      patterns: "data_*.tgz"
      file_type: file
    register: find_data_archives
    tags: [backup, files]

  - name: Assert we have at least one DB dump
    ansible.builtin.assert:
      that: find_db_dumps.matched > 0
    tags: [backup, database]

  - name: Assert we have at least one data archive
    ansible.builtin.assert:
      that: find_data_archives.matched > 0
    tags: [backup, files]

  # -------------------------------------------------------------------------
  # Register latest artifacts and fetch them
  # -------------------------------------------------------------------------
  - name: Set primary_backup_package fact
    ansible.builtin.set_fact:
      primary_backup_package:
        - "{{ (find_db_dumps.files     | sort(attribute='mtime', reverse=true) | first).path }}"
        - "{{ (find_data_archives.files| sort(attribute='mtime', reverse=true) | first).path }}"
    tags: [backup]

  - name: Fetch artifacts to control node
    ansible.builtin.fetch:
      src:  "{{ item }}"
      dest: "{{ control_node_fetch_dir }}"
      flat: true
    loop: "{{ primary_backup_package }}"
    register: res_fetch
    tags: [backup]

  - name: Set control_node_backup_package fact
    ansible.builtin.set_fact:
      control_node_backup_package: "{{ res_fetch.results | map(attribute='dest') | list }}"
    tags: [backup]

  # -------------------------------------------------------------------------
  # Record results of the find/assert/fetch steps
  # -------------------------------------------------------------------------
  - name: Record results of locate & fetch
    ansible.builtin.set_fact:
      _dr_report: "{{ _dr_report | combine({
        'backup': _dr_report.backup | default([])
                  + [
                      { task: 'Find DB dumps', host: inventory_hostname, rc: 0,
                        changed: false, failed: false,
                        msg: 'matched=' ~ find_db_dumps.matched },
                      { task: 'Find data archives', host: inventory_hostname, rc: 0,
                        changed: false, failed: false,
                        msg: 'matched=' ~ find_data_archives.matched },
                      { task: 'Fetch artifacts', host: inventory_hostname, rc: res_fetch.rc | default(0),
                        changed: res_fetch.changed | default(false),
                        failed: res_fetch.failed  | default(false),
                        msg: 'files fetched=' ~ (res_fetch.results | length) }
                    ]
      }, recursive=True) }}"
    tags: [always]

  # -------------------------------------------------------------------------
  # Generate CSVs for Protect stage
  # -------------------------------------------------------------------------
  - name: Create CSVs for Protect stage
    delegate_to: localhost
    run_once: true
    vars:
      report_items: "{{ _dr_report | dict2items }}"
    loop: "{{ report_items }}"
    loop_control: { label: "{{ item.key }}" }
    ansible.builtin.copy:
      dest: "/tmp/protect_{{ item.key }}_report_{{ _csv_time }}.csv"
      content: |
        Task,Host,ReturnCode,Changed,Failed,Message
        {% for r in item.value %}
        "{{ r.task }}",{{ r.host }},{{ r.rc }},{{ r.changed }},
        {{ r.failed }},{{ r.msg | replace('\n',' ') }}
        {% endfor %}
      mode: "0644"
    tags: [always]

###############################################################################
# PLAY 2 – TRANSFER  (control ➜ DR)  ➜  copy artifacts off-site
###############################################################################
- name: Stage 2 – Transfer (Control → DR)
  hosts: dr
  become: true

  vars:
    dr_incoming: /srv/dr_incoming
    _dr_report: {}
    _csv_time: "{{ ansible_date_time.iso8601_basic }}"

  tasks:
  - name: Ensure incoming directory exists
    ansible.builtin.file:
      path: "{{ dr_incoming }}"
      state: directory
      mode: "0750"
    register: res_in_dir
    tags: [transfer]

  - name: Copy artifacts from control node to DR
    ansible.builtin.copy:
      src:  "{{ item }}"
      dest: "{{ dr_incoming }}/"
      mode: preserve
    loop: "{{ hostvars[groups['primary'][0]].control_node_backup_package }}"
    register: res_copy
    tags: [transfer]

  # record
  - ansible.builtin.set_fact:
      _dr_report: "{{ _dr_report | combine({
        'transfer': [
          { task: 'Ensure dr_incoming', host: inventory_hostname,
            rc: res_in_dir.rc | default(0),
            changed: res_in_dir.changed | default(false),
            failed: res_in_dir.failed  | default(false),
            msg: res_in_dir.msg | default('') },
          { task: 'Copy artifacts to DR', host: inventory_hostname,
            rc: res_copy.rc | default(0),
            changed: res_copy.changed | default(false),
            failed: res_copy.failed  | default(false),
            msg: 'files copied=' ~ (res_copy.results | length) }
        ]
      }) }}"
    tags: [always]

  # CSV
  - name: CSVs for Transfer stage
    delegate_to: localhost
    run_once: true
    vars:
      report_items: "{{ _dr_report | dict2items }}"
    loop: "{{ report_items }}"
    loop_control: { label: "{{ item.key }}" }
    ansible.builtin.copy:
      dest: "/tmp/transfer_{{ item.key }}_report_{{ _csv_time }}.csv"
      mode: "0644"
      content: |
        Task,Host,ReturnCode,Changed,Failed,Message
        {% for r in item.value %}
        "{{ r.task }}",{{ r.host }},{{ r.rc }},{{ r.changed }},
        {{ r.failed }},{{ r.msg | replace('\n',' ') }}
        {% endfor %}
    tags: [always]

###############################################################################
# PLAY 3 – RECOVER  (DR site) ➜ restore when dr_action=failover
###############################################################################
- name: Stage 3 – Recover (DR site)
  hosts: dr
  become: true

  vars:
    incoming_dir: /srv/dr_incoming
    restore_root: /srv/dr_restore
    db_name:  myapp
    db_user:  postgres
    db_password: "pass@123"
    _dr_report: {}
    _csv_time: "{{ ansible_date_time.iso8601_basic }}"

  tasks:
  - name: End play unless failover requested
    ansible.builtin.meta: end_play
    when: (dr_action | default('standby')) != 'failover'

  - name: Create restore directory
    ansible.builtin.file:
      path: "{{ restore_root }}"
      state: directory
      mode: "0750"
    register: res_restore_dir
    tags: [restore, files]

  # --- locate archives ---
  - name: Find data archives on DR
    ansible.builtin.find:
      paths: "{{ incoming_dir }}"
      patterns: "data_*.tgz"
      file_type: file
    register: find_data_archives_dr
    tags: [restore, files]

  - name: Find DB dumps on DR
    ansible.builtin.find:
      paths: "{{ incoming_dir }}"
      patterns: "{{ db_name }}_*.sql.gz"
      file_type: file
    register: find_db_dumps_dr
    tags: [restore, database]

  # --- extract ---
  - name: Extract latest data archive
    ansible.builtin.unarchive:
      src: "{{ (find_data_archives_dr.files | sort(attribute='mtime', reverse=true) | first).path }}"
      dest: "{{ restore_root }}"
      remote_src: true
    when: find_data_archives_dr.matched > 0
    register: res_extract
    tags: [restore, files]

  # --- restore DB ---
  - name: Restore PostgreSQL dump
    ansible.builtin.shell: >
      bash -c 'gunzip -c "{{ (find_db_dumps_dr.files | sort(attribute="mtime", reverse=true) | first).path }}" |
               psql -U {{ db_user }} {{ db_name }}'
    environment: { PGPASSWORD: "{{ db_password }}" }
    when: find_db_dumps_dr.matched > 0
    changed_when: true
    register: res_restore_db
    tags: [restore, database]

  # --- start app ---
  - name: Start application service
    ansible.builtin.systemd:
      name: myapp
      state: started
      enabled: true
    register: res_service
    tags: [restore, services]

  # record
  - ansible.builtin.set_fact:
      _dr_report: "{{ _dr_report | combine({
        'restore': [
          { task: 'Create restore dir', host: inventory_hostname,
            rc: res_restore_dir.rc | default(0),
            changed: res_restore_dir.changed | default(false),
            failed: res_restore_dir.failed | default(false),
            msg: res_restore_dir.msg | default('') },
          { task: 'Find data archives', host: inventory_hostname,
            rc: 0, changed: false, failed: false,
            msg: 'matched=' ~ find_data_archives_dr.matched },
          { task: 'Find DB dumps', host: inventory_hostname,
            rc: 0, changed: false, failed: false,
            msg: 'matched=' ~ find_db_dumps_dr.matched },
          { task: 'Extract data archive', host: inventory_hostname,
            rc: res_extract.rc | default(0),
            changed: res_extract.changed | default(false),
            failed: res_extract.failed | default(false),
            msg: res_extract.msg | default('') },
          { task: 'Restore DB dump', host: inventory_hostname,
            rc: res_restore_db.rc | default(0),
            changed: res_restore_db.changed | default(false),
            failed: res_restore_db.failed | default(false),
            msg: res_restore_db.msg | default('') },
          { task: 'Start app service', host: inventory_hostname,
            rc: res_service.rc | default(0),
            changed: res_service.changed | default(false),
            failed: res_service.failed | default(false),
            msg: res_service.msg | default('') }
        ]
      }) }}"
    tags: [always]

  # CSV
  - name: CSVs for Recover stage
    delegate_to: localhost
    run_once: true
    vars:
      report_items: "{{ _dr_report | dict2items }}"
    loop: "{{ report_items }}"
    loop_control: { label: "{{ item.key }}" }
    ansible.builtin.copy:
      dest: "/tmp/recover_{{ item.key }}_report_{{ _csv_time }}.csv"
      mode: "0644"
      content: |
        Task,Host,ReturnCode,Changed,Failed,Message
        {% for r in item.value %}
        "{{ r.task }}",{{ r.host }},{{ r.rc }},{{ r.changed }},
        {{ r.failed }},{{ r.msg | replace('\n',' ') }}
        {% endfor %}
    tags: [always]
